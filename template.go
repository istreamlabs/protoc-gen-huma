package main

import "github.com/flosch/pongo2"

// bt wraps a value in backticks because there's no way to escape a backtick
// inside a Go multiline string.
func bt(val string) string {
	return "`" + val + "`"
}

// humaTemplate renders out Huma code from the protobuf inputs. Its main input
// is a `File` object which describes a single protobuf file and its contents,
// like enums and messages.
var humaTemplate = pongo2.Must(pongo2.FromString(`
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// sources: {{ file.Proto.Name }}
// plugin: protoc-gen-huma
package {{ file.PackageName }}huma

import (
	{% for import in file.Imports sorted -%}
		"{{ import }}"
	{% endfor %}
)

{% for enum in file.Enums %}
	{% if enum.Comment %}// {{ enum.Comment }}{% endif %}
	type {{ enum.Name }} string

	const (
		{% for value in enum.Values -%}
			{% if value.Comment %}// {{ value.Comment }}{% endif %}
			{{ enum.Name }}{{ value.Name }} {{ enum.Name }} = "{{ value.Label }}"
		{% endfor %}
	)

	var {{ enum.Name }}ValuesMap map[{{ enum.Name }}]{{ file.PackageName }}.{{ enum.ProtoGoName }} = map[{{ enum.Name }}]{{ file.PackageName }}.{{ enum.ProtoGoName }}{
		{% for value in enum.Values -%}
			"{{ value.Label }}": {{ file.PackageName }}.{{ enum.ProtoGoName }}({{ value.Value }}),
		{% endfor %}
	}

	var {{ enum.Name }}NamesMap map[{{ file.PackageName }}.{{ enum.ProtoGoName }}]{{ enum.Name }} = map[{{ file.PackageName }}.{{ enum.ProtoGoName }}]{{ enum.Name }}{
		{% for value in enum.Values -%}
			{{ value.Value }}: {{ enum.Name }}("{{ value.Label }}"),
		{% endfor %}
	}
{% endfor %}

{% macro tags(field) -%}
	json:"{{ field.JSONName }}{% if not field.Validation.IsRequired %},omitempty{% endif %}"
	{%- if field.Enum %} enum:"{% for v in field.Validation.EnumValues %}{{ v }}{% if not forloop.Last %},{% endif %}{% endfor %}"{% endif -%}
	{%- if field.Validation.HasMinimum %} minimum:"{{ field.Validation.Minimum|floatformat }}"{% endif -%}
	{%- if field.Validation.HasExclusiveMinimum %} exclusiveMinimum:"{{ field.Validation.ExclusiveMinimum|floatformat }}"{% endif -%}
	{%- if field.Validation.HasMaximum %} maximum:"{{ field.Validation.Maximum|floatformat }}"{% endif -%}
	{%- if field.Validation.HasExclusiveMaximum %} exclusiveMaximum:"{{ field.Validation.ExclusiveMaximum|floatformat }}"{% endif -%}
	{%- if field.Validation.MinLength %} minLength:"{{ field.Validation.MinLength }}"{% endif -%}
	{%- if field.Validation.MaxLength %} maxLength:"{{ field.Validation.MaxLength }}"{% endif -%}
	{%- if field.Validation.Pattern %} pattern:"{{ field.Validation.Pattern }}"{% endif -%}
	{%- if field.Validation.Format %} format:"{{ field.Validation.Format }}"{% endif -%}
	{%- if field.Validation.MinItems %} minItems:"{{ field.Validation.MinItems }}"{% endif -%}
	{%- if field.Validation.MaxItems %} maxItems:"{{ field.Validation.MaxItems }}"{% endif -%}
	{%- if field.Validation.Unique %} uniqueItems:"true"{% endif -%}
	{%- if field.Validation.ReadOnly %} readOnly:"true"{% endif -%}
	{%- if field.Validation.Deprecated %} deprecated:"true"{% endif -%}
	{%- if field.Validation.MultipleOf %} multipleOf:"{{ field.Validation.MultipleOf }}"{% endif -%}
	{%- if field.Example %} example:"{{ field.Example }}"{% endif -%}
	{%- if field.Comment %} doc:"{{ field.Comment }}"{% endif -%}
{%- endmacro %}

{% for msg in file.Messages %}
{% if msg.Comment %}// {{ msg.Comment }}{% endif %}
type {{ msg.Name }} struct {
	{% for field in msg.Fields -%}
		{% if field.Comment -%}
			// {{ field.Comment }}
		{% endif -%}
		{{ field.Name }} {{ field.GoType }} ` + bt(`{{ tags(field) }}`) + `
	{% endfor %}
}

{% if msg.OneOfs %}
func (m *{{ msg.Name }}) Resolve(ctx huma.Context, r *http.Request) {
	{%- for name, fields in msg.OneOfs sorted %}
		{
			seen := []string{}
			{%- for field in fields %}
				if !reflect.ValueOf(m.{{ field.Name }}).IsZero() {
					seen = append(seen, "{{ field.JSONName }}")
				}
			{%- endfor %}
			if len(seen) > 1 {
				ctx.AddError(&huma.ErrorDetail{
					Message:  "Only one of [{% for field in fields %}'{{ field.JSONName }}'{% if not forloop.last %}, {% endif %}{% endfor %}] allowed in '{{ msg.Name }}'",
					Location: seen[0],
					Value:    strings.Join(seen, ", "),
				})
			}
		}
	{%- endfor %}
}
{% endif %}

{% macro fieldfromproto(proto, field) -%}
	{% if field.GoType == "*time.Time" -%}
		if {{ proto }}.{{ field.ProtoGoName }} != nil {
			t := {{ proto }}.{{ field.ProtoGoName }}.AsTime()
			m.{{ field.Name }} = &t
		}
	{% elif field.IsPrimitive -%}
		m.{{ field.Name }} = {{ proto }}.{{ field.ProtoGoName }}
	{% elif field.IsRepeated -%}
		{
			tmp := {{ field.GoType }}{}
			for _, i := range {{ proto }}.{{ field.ProtoGoName }} {
				{% if field.Enum -%}
					enumValue := {{ field.GoType|slice:"2:" }}NamesMap[i]
					if enumValue == "" {
						continue
					}
					tmp = append(tmp, enumValue)
				{% else -%}
					if i == nil {
						continue
					}
					tmp = append(tmp, (&{{ field.GoType|cut:"[]"|cut:"*" }}{}).FromProto(i))
				{%- endif %}
			}
			m.{{ field.Name }} = tmp
		}
	{% else -%}
		{% if field.Enum -%}
			if v, ok := {{ field.GoType }}NamesMap[{{ proto }}.{{ field.ProtoGoName }}]; ok {
				m.{{ field.Name }} = v
			}
		{% else -%}
			if {{ proto }}.{{ field.ProtoGoName }} != nil {
				{% if field.IsMap -%}
					if m.{{ field.Name }} == nil {
						m.{{ field.Name }} = {{ field.GoType }}{}
					}
					for k, v := range {{ proto }}.{{ field.ProtoGoName }} {
						m.{{ field.Name }}[k] = (&{{ field.GoType|cut:"map[string]"|cut:"*" }}{}).FromProto(v)
					}
				{% else -%}
					if m.{{ field.Name }} == nil {
						m.{{ field.Name }} = &{{ field.GoType|cut:"*" }}{}
					}
					m.{{ field.Name }}.FromProto({{ proto }}.{{ field.ProtoGoName }})
				{%- endif %}
			}
		{%- endif %}
	{%- endif %}
{%- endmacro %}

// FromProto converts a proto message to the Huma representation.
func (m *{{ msg.Name }}) FromProto(proto *{{ file.PackageName}}.{{ msg.ProtoGoName }}) *{{ msg.Name }} {
	{% for field in msg.Fields -%}
		{% if not field.OneOf -%}
			{{ fieldfromproto("proto", field) }}
		{% endif %}
	{%- endfor %}

	{% for name, fields in msg.OneOfs sorted %}
		switch oneof := proto.{{ name }}.(type) {
			{% for field in fields %}
				case *{{ file.PackageName }}.{{ msg.ProtoGoName }}_{{ field.ProtoGoName }}:
					{{ fieldfromproto("oneof", field) }}
			{% endfor %}
		}
	{% endfor %}

	return m
}

{% comment %}
	Sets the proto's one-of field to the one-of struct which contains the
  one-of value. This should be called anytime a value has been set as it
	checks if we are in a one-of and does nothing if not.
{% endcomment %}
{% macro oneOfSet(proto, field) -%}
	{% if proto == "oneof" %}
		proto.{{ field.OneOf }} = oneof
	{% endif %}
{%- endmacro %}

{% macro fieldtoproto(proto, field) -%}
	{% if field.GoType == "*time.Time" -%}
		if m.{{ field.Name }} != nil && !m.{{ field.Name }}.IsZero() {
			{{ proto }}.{{ field.ProtoGoName }} = timestamppb.New(*m.{{ field.Name }})
			{{ oneOfSet(proto, field) }}
		}
	{% elif field.IsPrimitive -%}
			{{ proto }}.{{ field.ProtoGoName }} = m.{{ field.Name }}
			{% if proto == "oneof" -%}
				if !reflect.ValueOf(m.{{ field.Name }}).IsZero() {
					{{- oneOfSet(proto, field) -}}
				}
			{%- endif %}
	{% elif field.IsRepeated -%}
		{
			tmp := {{ field.ProtoGoType }}{}
			for _, i := range m.{{ field.Name }} {
				{% if field.Enum -%}
					if v, ok := {{ field.GoType|slice:"2:" }}ValuesMap[i]; ok {
						tmp = append(tmp, v)
					}
				{% else -%}
					if i == nil {
						continue
					}
					tmp = append(tmp, i.ToProto(nil))
				{%- endif %}
			}
			{{ proto }}.{{ field.ProtoGoName }} = tmp
			{# one-of can't be repeated, no need for oneOfSet(...) #}
		}
	{% else -%}
		{% if field.Enum -%}
			if m.{{ field.Name }} != "" {
				{{ proto }}.{{ field.ProtoGoName }} = {{ field.GoType }}ValuesMap[m.{{ field.Name }}]
				{{ oneOfSet(proto, field) }}
			}
		{% else -%}
			if m.{{ field.Name }} != nil {
				{% if field.IsMap -%}
					if {{ proto }}.{{ field.ProtoGoName }} == nil {
						{{ proto }}.{{ field.ProtoGoName }} = {{ field.ProtoGoType }}{}
					}
					for k, v := range m.{{ field.Name }} {
						{{ proto }}.{{ field.ProtoGoName }}[k] = v.ToProto({{ proto }}.{{ field.ProtoGoName }}[k])
					}
					{{ oneOfSet(proto, field) }}
				{% else -%}
					{{ proto }}.{{ field.ProtoGoName }} = m.{{ field.Name }}.ToProto({{ proto }}.{{ field.ProtoGoName }})
					{{ oneOfSet(proto, field) }}
				{% endif %}
			}
		{%- endif %}
	{%- endif %}
{%- endmacro %}

// ToProto converts a Huma representation to a proto message.
func (m *{{ msg.Name}}) ToProto(proto *{{ file.PackageName }}.{{ msg.ProtoGoName }}) *{{ file.PackageName }}.{{ msg.ProtoGoName }} {
	if proto == nil {
		proto = &{{ file.PackageName }}.{{ msg.ProtoGoName }}{}
	}

	{% for field in msg.Fields -%}
		{% if field.OneOf -%}
			{
				oneof := &{{ file.PackageName }}.{{ msg.ProtoGoName }}_{{ field.ProtoGoName }}{}
				{{ fieldtoproto("oneof", field) }}
			}
		{% else -%}
			{{ fieldtoproto("proto", field) }}
		{% endif %}
	{%- endfor %}

	return proto
}
{% endfor %}
`))
